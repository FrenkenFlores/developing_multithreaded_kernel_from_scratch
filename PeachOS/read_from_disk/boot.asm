ORG 0
BITS 16 ; Define that the assembler will use 16 bytes.


; Some BIOS systems use USB FFD (Floppy Flash Drive)
; (not USB HDD - Hard Disk Drive, or something else) emulation
; which gives them the ability to interpret USB flash drive as hard disk drive.
; The BIOS expect the BPB at the begining of the sector (512 bytes), it finds it
; and then proceed to modify the BPB after it is loaded into memory to reflect the drive geometry.
; The BIOS Parameter Block is the block that holds all info about the Master Boot Record sector.
; read https://wiki.osdev.org/FAT for information.
; By adding a fake BPB which consists of 36 bytes, it should overwrite it with the actual values.
; If we don't add BPB it will overwrite first 36 bytes including our bootloader code.

; The first 3 bytes of the BPB.
init:
    ; jump over the BPB to the code.
    jmp short main
    nop
; The last 33 bytes of the BPB.
times 33 db 0; Create a fake BIOS Prameter Block

main:
    ; 0x7c00 is the segment address that the BIOS will execute from the bootloader.
    ; The actual location of the beginning of a segment in the linear address space
    ; can be calculated with segment√ó16: 0x7c0 * 0x10 = 0x7c00
    ; 0x7c0 is the logical address, it is generated by the CPU,
    ; it is used as a reference to access the physical memory location by CPU.
    jmp 0x7c0:start

start:
    ; Different CPU can initialize registers differently, there is no garentee that
    ; they will be set correctly, that is why its important to init them by ourselves.

    ; Clear and disable interrupts, they use these registers and we don't want
    ;interrrupts to bother us while initailizing them.
    cli
    mov ax, 0x7c0
    mov ds, ax
    mov es, ax
    mov ax, 0x00
    mov ss, ax
    mov sp, 0x7c00
    sti ; Enable interrupts
    ; http://www.ctyme.com/intr/rb-0607.htm
    mov ah, 0x2 ; Read sector command.
    mov al, 2 ; Read two sectors.
    mov ch, 0
    mov cl, 1 ; Starts from one (C:0,S:1,H:0).
    mov dh, 0
    ; dl will be set by default, it will have the drive number that it loaded from.
    mov bx, buffer ; es is elready set above.
    int 0x13; Read.
    jc error; If the carry was set by int 0x13, then jump to error.
    ; Write the message from the buffer that will be filled with data after int 0x13.
    mov si, buffer
    call print
    jmp $ ; Infinite loop, jump to it self.

error:
    mov si, error_msg
    call print
    jmp $

print:
    mov bx, 0
; Note, in NASM period (., dot) is used for local labels, you also can access them globally by
; lable_name.local_lable, like print.done, etc.
.loop:
    ; (http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc161.htm)
    lodsb ; Load one string byte from the place where si is pointing to in al register and increment si.
    cmp al, 0
    je .done
    call print_char
    jmp .loop
.done:
    ret

print_char:
    mov ah, 0eh ; choose 0eh command that will print char from al register.
    int 0x10 ; call interrupt.
    ret

error_msg: db 'Failed to load sector', 0

times 510 - ($ - $$) db 0   ; Fill at least 510 bytes of data.
; $ points to current line, $$ points to the begining of the section,
; ($ - $$) tells us how far we are in the current section.
; To find out how much bytes left to fill the segment with 510 bytes, we must substract.
dw 0xAA55 ; Add the boot signature. It should be 0x55AA, but Intel are little endian.
; BIOS will look for this signature in all storages, once it find it,
; it will load the bootloader that haves that signature.
; dw and db put the word or byte into the file as binary.

; We choose the bin (binary) type because the processor will run this file,
; the processor has no concept of executable files.
; nasm -f bin ./boot.asm -o ./boot.bin

; Check the binary file by executing: ndisasm ./boot.bin
; Run the bootloader by executing: qemu-system-x86_64 -hda ./boot.bin

; The code after the boot signature will be never read, but we can reference it in
; the first sector.
; We create a new empty label that we will write to.
buffer:
